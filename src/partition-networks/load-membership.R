#############################################################################################
# Loads membership vectors processed using external tools.
# 
# 01/2016 Vincent Labatut
#############################################################################################
source("src/define-constants.R")


#############################################################################################
# Loads the partition estimated by the external tools (their file format needs a specific
# conversion processing).
#
# f.name: the path and name of the file or folder to load (depends on the format).
# algo.name: code representing the concerned (external) partitioning algorithm.
# keep.tmp: whether or not to keep the original files generated by the algorithm.  
#
# returns: the corresponding partition as a membership vector.
#############################################################################################
load.external.partition <- function(folder.name, result.filename, algo.name, keep.tmp)
{	
    if(startsWith(algo.name,COR.CLU.ExCC))
        #result <- load.ExCC.partition(folder.name, result.filename)
		result <- read.table(file.path(folder.name, result.filename))$V1
    else if(startsWith(algo.name,ENUMCC)){
        result = NA # if it is NA, then, there will not be any post processing for membership files/log files
        #result <- read.table(file.path(folder.name, result.filename))$V1
    }
	else if(startsWith(algo.name,RNSCC)){
		result = NA # if it is NA, then, there will not be any post processing for membership files/log files
		#result <- read.table(file.path(folder.name, result.filename))$V1
	}
	else if(startsWith(algo.name,COR.CLU.ILS) || startsWith(algo.name,COR.CLU.GRASP))
		result <- load.ils.grasp.partition(folder.name, result.filename, keep.tmp)
	else if(startsWith(algo.name,COR.CLU.NIFTY) || startsWith(algo.name,COR.CLU.MLMSB)
			|| startsWith(algo.name,COR.CLU.SA.CC) || startsWith(algo.name,COR.CLU.TS.CC)
			|| startsWith(algo.name,COR.CLU.Brusco.VNS.CC))
	{	file.name <- file.path(folder.name, result.filename)
		
		result <- read.table(file.name)$V1
	}
	else if(startsWith(algo.name,CODE.COR.CLU.GAEC.KLj.CC) 
			|| startsWith(algo.name,CODE.COR.CLU.ICP.GAEC.KLj.CC)
			|| startsWith(algo.name,CODE.COR.CLU.MP.GAEC.KLj.CC))
	{
		result <- load.membership.LPMP(folder.name, result.filename)
	}
	else {
		# others
	}
    
    return(result)
}



#############################################################################################
# Loads the partition estimated by the ils/grasp tool.
# 
# part.folder: Main folder meant to contain the results of the partitioning approach.
# algo.name: code representing the concerned (external) partitioning algorithm.
# keep.tmp: whether or not to keep the original files generated by the algorithm.  
#
# returns: the corresponding partition as a membership vector.
#############################################################################################
load.ils.grasp.partition <- function(part.folder, result.filename, keep.tmp=TRUE)
{	
    #	# set up the file name
    #	tmp <- strsplit(x=algo.name, split="_", fixed=TRUE)[[1]]
    #	rcc.flag <- strsplit(x=tmp[1], split="-", fixed=TRUE)[[1]][2]
    #	file.name=NA
    #	if(rcc.flag=="RCC")
    #		file.name <- file.path(part.folder, "rcc-result.txt")
    #	else
    #		file.name <- file.path(part.folder, "cc-result.txt")
    
    file.name <- file.path(part.folder, result.filename)
    print(file.name)
    # open and read the file
    tlog(14,"Trying to load file: \"",file.name,"\"")
    con <- file(file.name, "r")
    lines <- readLines(con)
    close(con)
    
    
    # process the file content
    i <- 4
    line <- lines[i]
    res <- list()
    while(line!="")
    {  # process current line
        #print(line)
        line <- strsplit(x=line, "[ ", fixed=TRUE)[[1]][2]
        line <- strsplit(x=line, " ]", fixed=TRUE)[[1]][1]
        nodes <- as.integer(strsplit(x=line," ", fixed=TRUE)[[1]]) + 1 # plus one because C++ starts counting from zero
        res[[length(res)+1]] <- nodes
        
        # process next line
        i <- i + 1
        line <- lines[i]      
    }
    
    # build the membership vector
    mx <- max(unlist(res))
    membership <- rep(NA,mx)
    for(i in 1:length(res))
    {  nodes <- res[[i]]
    membership[nodes] <- i 
    }
    
    # retain only the partiton info file by changing its name
    id=0
    file.copy(from=file.name, to=file.path(part.folder, paste0(ALGO.RESULT.FILE.PREFIX,id,".txt")))
    
    
    return(membership)
}



################################################################################
# Loads the partition estimated by the ExCC tool.
# 
# file.name: the path and name of the file to load.
#
# returns: the corresponding partition as a membership vector.
###############################################################################
load.ExCC.partition <- function(part.folder, result.filename)
{	
    ExCC.output.file <- file.path(part.folder, result.filename)
    #	if(algo.name == COR.CLU.ExCC) TODO
    #		ExCC.output.file <- file.path(part.folder, "ExCC-result.txt")
    
    # open and read the file
    #	print(file.name)
    con <- file(ExCC.output.file, "r")
    lines <- readLines(con)
    close(con)
    
    
    # process the file content
    i <- 1
    line <- lines[i]
    res <- list()
    
    # TODO: change here if the result file has more information than just the partition
    # in that case, put this line: while(line!="")
    while(!is.na(line)) # line!=""
    {  # process current line
        #print(line)
        line <- strsplit(x=line, "[", fixed=TRUE)[[1]][2]
        line <- strsplit(x=line, "]", fixed=TRUE)[[1]][1]
        
        # we increment by 1 at the end because C++ starts counting from 0
        nodes <- as.integer(strsplit(x=line,", ", fixed=TRUE)[[1]]) + 1
        
        res[[length(res)+1]] <- nodes
        
        # process next line
        i <- i + 1
        line <- lines[i]  
    }
    
    
    # build the membership vector
    mx <- max(unlist(res))
    membership <- rep(NA,mx)
    for(i in 1:length(res))
    {  nodes <- res[[i]]
    membership[nodes] <- i 
    }
    
    
    return(membership)
}




# 1st column: source ids, 2nd column: target ids, 3rd column: 0 or 1, where 0 means source and target vertices are in the same cluster (i.e., uncut edge)
load.membership.LPMP  <- function(folder.name, result.filename){
	result = read.table(file.path(folder.name, result.filename), sep=" ")
	uncut.indxs = which(result$V3 == 0)
	el = cbind(result[uncut.indxs,1]+1,result[uncut.indxs,2]+1) #+1 for handling vertiecs having id 0
	g = graph_from_edgelist(el, directed = FALSE)
	membership = components(g)$membership
	return(membership)
}
